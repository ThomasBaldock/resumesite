<html>
<head>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic|Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="test.css">
    <title>Thomas Baldock's Blog</title>
    <meta name="viewport" content="width=device-width">
    <script>
      fetch('https://57vvf01f32.execute-api.ap-southeast-2.amazonaws.com/Prod/put')
            .then(() => fetch('https://57vvf01f32.execute-api.ap-southeast-2.amazonaws.com/Prod/get'))
            .then(response => response.json())
            .then(data => {
                document.getElementById('visitorCount').innerText = data['counter']
            })
      </script>
</head>
<body>
<div class="links"><a href=mailto:thomas.m.baldock@gmail.com>Email</a> &emsp; <a href="https://www.linkedin.com/in/thomas-m-baldock" target="_blank">LinkedIn</a>  &emsp; <a href="https://github.com/ThomasBaldock" target="_blank">Github</a> &emsp; <a href="/blog">Blog</a>  </div>
<div class="head">
<div class="thomasbaldockheader"><a href="/" style="text-decoration: none">Thomas Baldock</a></div>
<div class="subhead"> Melbourne, Australia - 
  <div class="display-date">
      <span id="day">day</span>,
      <span id="month">month</span>
      <span id="daynum">00</span>
      <span id="year">0000</span>
    </div></div>
    <div class="visitorcount"><span style="font-style: italic;">You are visitor number: <span id="visitorCount">loading...</span></div>
</div>
<div class="badges"><img src="images/cloud-practioner-badge.png" alt="Certified Cloud Practioner Badge" width="100" height="100"><img src="images/restart-graduate-badge.png" alt="AWS Re/Start Graduate Badge" width="100" height="100"></div><br>
<div class="contentb">
  <div class="collumnb">
    
    <div class="blogtitle"><a href="/blog/cs-3-arrays.html" style="text-decoration: none">Tuesday, 17th of January 2023</a></div>
    <span class="blogheadline">An Awry Array</span><br><br>
    <img src="images/compuer-chip.png" alt="Computer-image" class="cloudhead"><br>
    
    In week 2 of edX's CS50x, we returned to our study of the programming language C. This week we took a deeper look at the building-blocks of computers and how a programming language works from the bottom up.<br><br>  
    
    I went into this week confidently after last week's success but struck the wall in the last problem set. I will explain in detail later however I learnt many things - not just about that particular problem set - but also how to approach issues more generally.<br><br> 
    
    We started the week returning to the concept of compiling. In Week 1 we had used been using the make utility to 'compile' our source code. This week we learnt that this utility is not actually a compiler, rather, it is a command which executes the compiler for C, called Clang, along with some arguments pre-programmed by CS50x. <br><br>
    
    I did some research of my own to better understand this utility. I discovered outside of the Integrated Development Environment provided by CS50, the make utility needs a makefile to provide the process with the necessary instructions and commands. <br><br>
    
    I recalled I used a Makefile when I completed the Cloud Resume challenge. You can read about my Cloud Resume here. This file was used by Amazon Web Services Serverless Application Model (AWS SAM), which is a Command Line Interface tool which can build serverless applications on AWS. The Makefile was used to automate the building process when we pushed our code from Github to AWS. Several macros were stored in the file and each one provided AWS SAM with one or more commands, along with any dependencies, which needed to be executed by the compiler. I still don't have a complete grasp of how it works, but being able to link this concept to a previous project strengthened my understanding.<br><br>
    
    To push this thinking even further, this realisation also gave me a better understanding of how AWS SAM works as well. Effectively, running this tool packages your files in a format with can be understood by the AWS Cloud infrastructure. In other words, we are compiling the code from source code into AWS Cloud machine code.<br><br>
    
    Back in this week's learning, we investigated the stages that a compiler like Clang goes through. <br><br>
    
    First is preprocessing. This involves transferring header files into the source code which is to be converted.<br><br>
    
    Second is a step, also called compiling. In this step, the program is converted into assembly code. This is where architectures like x86 and ARM begin to differ. <br><br>
    
    The third step, assembling, transforms assembly code into machine code (binary, i.e. 0s and 1s).<br><br>
    
    The final step, linking, converts the code from included libraries and combines it with the program's machine code. From this point the executable file is outputted.  From my experience, the final result is often called the binary of a program. I had trouble understanding what this mean in the past, so I'm glad for the clarification. <br><br>
    
    Perhaps as some foreshadowing from our teachers of what lay ahead with this week's problem sets, we were told about the inevitability of writing mistakes, or bugs, when coding. We were then provided with some debugging techniques to eliminate these errors. <br><br>
    
    The first involved printing variables often as a way of checking the values stored by variables at certain points of process.<br><br>
    
    A more sophisticated tool we were shown was the in-built debugger in our IDE which allows you to set breakpoints in code, keeps track of the values of each variable and control the flow of the program with Step Over a breakpoint button, and the Step Into and Step Out (of a function) buttons.<br><br>
    
    In my AWS bootcamp, which included a week spent on Python, we learnt how to use this debugger. However, I have been reticent to use it because in my past coding experiences, I have managed to eliminate bugs with either the printing technique or through a 'brute force' method of staring at my code hoping for a revelation. I was glad for this refresher and needed to have my eyes opened to its benefits again. However, it was not until I encountered the roadblock at the end of this blog post that I allowed them to fully open.<br><br>
    
    A third technique were taught was 'rubber-ducking'. This involves talking through problems with someone else, and in the absence of a living person, turning to an inanimate object. The concept is that by talking through your code line by line helps trigger the light-bulb moment when you come to something that sounds illogical.<br><br>
    
    We then returned to the concept of data types touched on in Week 0. In this week, we learnt how these different types utilise system resources. <br><br>
    
    We then used a diagram overlaid an image of a memory chip to visualise how data is stored in memory. In this grid we saw that each data type takes up a different amount of space in memory. <br><br>
    
    We then considered how three variables in a program would be stored in memory. We learnt they would be stored consecutively. <br><br>
    
    We were then taught about arrays which follows the same principle. An array is a way of storing data together in a way that makes it more accessible to the program. Despite linking the data together however, in memory, it's treated in a similar way as if the data was seperate variables and takes up the same amount of space.<br><br>
    
    Building on this, we learnt that strings aren't really their own data type. They're actually arrays of one-byte char(acters). The one difference between a string and a typical array is the presence of an unusual zero character at the end of strings position in-memory. This char is called the NUL character and it occurs in the language C as an indicator of when a string ends and another begins.<br><br>
    
    We then learnt about different C libraries and some of their useful functions that we can draw on by including a call for the library in the header of our program. Some useful functions include the get_string() function from the cs50.h library, which turns user input into a string, and the strlen() function from the string.h library, which measure the length of a string, excluding the NUL character. <br><br>
    
    We finished the weeks lecture by returning full circle to a discussion about how command line arguments that can be used by commands, like make and Clang can also be used with our programs.<br><br>
    
    In all our C programs so far, we have been starting our programs in this fashion<br><br>
    
    #include < studio.h >  <br>
    
    int main(void)<br>
    
    In this example, the void specifies that the command to run the program, doesn't take any command line arguments.<br><br>
    
    However it is possible to specify your program to need arguments!<br><br>
    
    This can be done with this opening, with void becoming…<br><br>
    
    int main (int argc, string argv[])<br><br>
    
    Argument count (argc) is the number of command line arguments given by user, and Argument Vector (argv) is an array of the characters passed as arguments, (notably including the program command as one of the arguments). This can be used to load programs with values without the need for responding to prompts, making the process of running programs much more convenient.<br><br>
    
    The last topic we covered were exit statuses. We learnt these can be used for automating testing of code or determining if a program has succeeded or failed. This explains why we’ve begun all our program with int main. It is because when the program finishes, as is necessary for all variables in c, to specify the data type of the value which will be returned. <br><br>
    
    In our programs, as we haven't coded any value to be returned, the 0 status, meaning success, is what has been returned. We learnt how we can instead build our code to be fault tolerant, in so much as if there is an error in input for the program, the program returns a value, ie 1, indicating the error. This can be implemented to stop a program running completely when an error is detected, saving time and restarting correctly faster. This final bit of teaching helped me to understand how error codes - of which we all are probably familiar - are produced.<br><br>
    
    <strong>Problem Sets</strong><br><br>
  
    The first lab was the easiest task for the week. We were supplied an array called POINTS and we tasked with calculating the Scraable score for any word inputted by the user. It was quite an easy task and involved us matching each letter with their corresponding position in the 26 value points array. The trick was treat all values of the text as either all uppercase or lowercase, it didn't matter which, so long as they were the same. From there, you convered the string characters to their decimal value, and then subtracted the decimal number which was the postion of either the capital A or lowercase a on the ASCII chart. From there, that number could be used to call the corresponding position in the POINT's array. <br><br>
    
    This week's first problem set tasked us with finding the reading level of any given text using the Coleman-Liau index.<br><br>

    <a href="/blog/cs-3-arrays.html">Read more.</a><br><br>

    <hr class="descriptionline"><br>

    <div class="blogtitle"><a href="/blog/cs-2-c.html" style="text-decoration: none">Wednesday, 7th of December</a></div>
    <span class="blogheadline">The Man and the C</span><br><br>
    <img src="images/mario.png" alt="Mario" class="cloudhead"><br>
    <p>
      After a short holiday I've returned to continue with my learning in cs50's Introduction to Computer Science. This week, we progress from the visual coding language Scratch to a more powerful language called C.<br><br>
      This will be another introductory language which we will use as a springboard to other languages in later weeks. The aim is to gain an understanding of the typical framework of programming languages.<br><br>
      To start the lecture, we recalled our understanding of the basic ideas in programming, like functions, conditionals, and loops and learnt how they can be executed in C.<br><br>
      We learned that C is a more opaque language than Scratch - requiring a knowledge of a more sophisticated and less human-readable syntax - but there are methods to ensure code is made easier to follow. Methods include formatting of code, efficiency of algorithms, adding clear comments and whether the code solves problem as intended.<br><br>
      Our first program mirrored that of our first Scratch demo, printing “hello, world”. Immediately, it's clear there are a few extra requirements in this language for a simple program to function, such as the inclusion of Standard Input and Output header (stdio.h) and the loading of a main function.<br><br>
      After this demo we learnt about Integrated Development Environments which can be used write, translate and run code and terminal windows. And building on our understanding of the binary system - which computers use to represent and process information - we learnt the difference between source code and machine code.<br><br>
      In this week's study, for example, source code is written in the high-level, moderately human-readable language C, however, in it's initial form, it is not able to give instructions to a computer. The source code, in order for the computer to understand it, needs to be translated - or compiled - into machine code by a program called a compiler. In the IDE provided by this course, we can compile our source code by using the 'make' command.<br><br>
      After an overview of Linux concepts necessary for this weeks problems sets we moved onto working through some basic programs in C, in order to introduce to us to the syntax and style requirements of C and how it uses data types, functions, arguments, loops, operators, etc.<br><br>
      One element of C's style is the ability it has to condense code into more succint instructions. One such example is a generic while loops that involves counter incrementing.
      <img src="images/example-while-loop-long.png" alt="Long While Loop" class="architecture"><br>
      Which with some rearranging can be displayed in this shortened format.
      <img src="images/example-while-loop-short.png" alt="Shortened While Loop" class="architecture"><br>
      To end the lecture, we discussed the limitations of 32-bit and less-so 64-bit systems when representing real numbers with precision, and how this imprecision leads to integer overflow. This happens when an arithmetic operation requires a value which is outside the range of a computer's capacity to represent with bits i.e. numbers larger than approx. ± 2.2 billion cannot be represented by 32-bits). We discussed some solutions to these problems, or, in other words, how to make code more “correct”.<br><br>
      <strong>Problem Sets</strong><br><br>
  To complete the week's work we needed to complete to problem sets. The first involved, recreating the pyramid in the original Super Mario Bros using ASCII art. The second tasked us with calculating the minimum number of coins needed when dispensing change.<br><br>
  The second task had most of the code provided, and just needed me to make some changes, inputing simple arithmetic into several pre-formed functions. It was more of an exercise in repetition to drill in familiarity with the syntax of C, so not much explanation is necessary.<br><br>
  The first task - recreating the Mario pyramid using # as bricks - was a greater challenge, and worth recounting.<br><br>
  <img src="images/pyramid-game.png" alt="The Mario Pyramid" class="cloudhead"><br>
  In the lecture we were shown how to create a square grid of n x n size, with n being a size inputted by user. <br><br>
  <img src="images/grid.png" alt="Grid coded with C" class="cloudhead"><br>
  The code looked like this.<br><br>
  <img src="images/grid-code.png" alt="Code which prints Grid" class="architecture"><br>
  This code works by nesting one loop within another. The outer loop (using int i) is responsible for beginning each row, while the row number is less than n. The inner loop (using int j) prints a number of # corresponding to n.<br><br>
  I inferred the code we would need to print the Mario pyramid would follow a similar scheme. After several failed attempts to print the pyramids out right, I decided to break down my task into segments. In the first segment, I decided to simply try to print the correct number of # I would need per line (ie row one would need one #, row two needed two #, etc.), looking like the image below.<br><br>
  <img src="images/pyramid-wrong.png" alt="Wrong Pyramid" class="cloudhead"><br>
  This was the code for the back-to-front pyramid<br><br>
  <img src="images/pyramid-wrong-code.png" alt="Wrong Pyramid" class="architecture"><br>
  Once I had this pyramid, it took a litle head-scratching for me to work out how to print the mirror image. I realised that I needed to add a step within the loop, one that printed a space using the inverse of the formula to print hashes. This diagram, replacing spaces with periods, shows this correlation. In row 1, 7 periods would need to be printed, and one hash.<br><br>
  <img src="images/correct-pyramid-periods.png" alt="Pyramid with Periods" class="cloudhead"><br>
  The code I ended up with looked like this.
  <img src="images/correct-pyramid-code.png" alt="Code for correct Pyramid" class="architecture"><br>
  Resulting in the correct solution.<br><br>
  <img src="images/correct-pyramid.png" alt="The Mario Pyramid Printed with C" class="cloudhead"><br>
  This was another rewarding week!<br><br>
    <hr class="descriptionline"><br>
    
    <h3>Thursday, 6th of October</h3>
    <span class="blogheadline">Getting Started</span><br><br> 
    <iframe width="485" height="273" src="https://www.youtube.com/embed/caXPtlRzH80" class="game" title="The Cloud Developer Workbook - 01 - Getting Started" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>
    <hr class="descriptionline"><br>

    <div class="blogtitle"><a href="/blog/intro-to-cs-scratch-project.html" style="text-decoration: none">Wednesday, 5th of October</a></div>
    <span class="blogheadline">The Shell Game</span><br><br> 
    <img src="images/conjurer.jpg" alt="The Shell Game" class="cloudhead"><br>
      <p>Just a quick one here. I have started <a href="https://www.edx.org/course/introduction-computer-science-harvardx-cs50x" target="_blank">cs50's Introduction to Computer Science</a> and made it through week 0. In this block we were introduced to the fundamental concepts of computer science.<br><br>
        We touched on how the binary system is used to represent all kinds of information e.g. text, images, videos, sounds, emojis, etc on computers. We learnt computer science can be simplified into two components - inputs and outputs, and that essentially, computer science is a form of problem solving, using algorithms (step-by-step instructions on how to process inputs to produce required outputs).<br><br>
        Through a basic example (finding a name in a phone book) we visualised how an algorithm's efficiency can be calculated. We used this example to show how an algorithm's efficiency can be represented using a simple chart.<br><br>
    <img src="images/algorithmic-efficiency.png" alt="Algorithmic-efficiency" class="cloudhead"><br>
        We then experminted with writing 'pseudocode' using quasi functions (pick up), conditionals (if, else if), loops (for, return to line x) and boolean expressions (is person on page? yes or no). The pseudocode that was used to find any name in the phone book was this:<br><br>
        1  &nbsp;Pick up phone book<br>
        2  &nbsp;Open to middle of phone book<br>
        3  &nbsp;Look at page<br>
        4  &nbsp;If person is on page<br>
        5  &nbsp;&emsp;Call person<br>
        6  &nbsp;Else if person is earlier in book<br>
        7  &nbsp;&emsp;Open to middle of left half of book<br>
        8  &nbsp;&emsp;Go back to line 3<br>
        9  &nbsp;Else if person is later in book<br>
        10 &nbsp;&emsp;Open to middle of right half of book<br>
        11 &nbsp;&emsp;Go back to line 3<br>
        12 &nbsp;Else<br>
        13 &nbsp;&emsp;Quit<br><br>
        The lecture finished with an introduction to the graphical programming language called <a href="https://scratch.mit.edu/" target="_blank">Scratch</a>, developed by MIT. This language has a highly human-readable form and bridges the gap between pseudocode and computer code. We had a look at some examples of previous student's projects, before we were sent out into the ether to come up with and execute our own idea.<br><br>
        After a short time experimenting with the language, I decided to recreate the Shell Game in Scratch. Here's my finished project.<br><hr class="descriptionline"><br>
        <iframe src="https://scratch.mit.edu/projects/741040546/embed" class="game" allowtransparency="true" width="485" height="402" frameborder="0" scrolling="no" allowfullscreen></iframe><br><hr class="descriptionline"><br>
        I've had some experience making a small game with python (battleship) however, this time my efforts were unguided. Admittedly, Scratch is very intuitive - still, working through the entire process helped reinforce some concepts for me. Most notably - the concept of exit status. It took some time for me to work how to integrate the seperate 'puzzle pieces' of my project, until I discovered the 'broadcast message' feature of Scratch. From this point, it was much clearer how I could integrate my puzzle pieces together.<br><br>
        I had a lot of fun with this week's block - particularly David J. Malan's energetic stage presence. He seems to me to be the Freddie Mercury of the Computer Science world! I'm really looking forward to next week's learning.
      </p>
      </p><br><hr class="descriptionline"><br>

    
    <div class="blogtitle"><a href="/blog/hello-world" style="text-decoration: none">Thursday, 8th of September</div></a>
    <p>Hello world! It's been quite some time since my last blog, back at the beginning of my journalism career.<br><br> 
      Now I found myself neither gainfully employed as a member of the press nor in the manufacturing field I followed it into. And yet, here I am, more excited for the future than I have ever been. So what exactly am I so excited about? Before I start, I'd like to acknowledge I will be breaking the cardinal rule of journalism: never, EVER put yourself in the story. However, not only am I allowing myself to ignore my training - but in this era of personal branding - it is encouraged. I can BE the story.<br><br> 
      So then, what is my story?<br></p>
      <span class="blogheadline">MAN TAKES LEAP OF FAITH INTO CLOUD</span><br><br>
      <img src="images/head-in-the-cloud.png" alt="Head in the cloud" class="cloudhead"><br>
      <p>There are many ways to follow this headline. The truest account - and please respect what remains of my journalistic integrity - goes something like this.<br><br> 
      I've always harboured an interest in computers so when the Digital Jobs Program came on my radar I jumped at the opportunity - even though I was employed at the time as an assistant manager at a manufacturing company. I choose the AWS Re/Start course because it covered a wide variety of topics and would provide a decent foundation for a career change. I didn't know much about cloud computing but the syllabus really appealed to me and I was ready to give it my all.<br><br> 
      So I left my job to take on this program and take a step into the great unknown.
      Luckily for me, I loved the course from the outset. I was spending my days and evenings absorbing as much new information as I possibly could. I then came across Forest Brazeal's 'Cloud Resume Challenge' which is touted as the ultimate test for anyone looking to get into a cloud career.  The premise of the project is simple - host your resume in the cloud. There are, however, several conditions.<br><br> 
      <b>1.</b> Get an AWS certification<br>
      <b>2.</b> Write the resume in HTML & styled with CSS<br>
      <b>3.</b> Deploy as an Amazon S3 Static website<br>
      <b>4.</b> Use a custom DNS Domain name with HTTPS security<br>
      <b>5.</b> Include a visitor counter made from Javascript, DynamoDB, API Gateways and Lambda functions (written in Python)<br>
      <b>6.</b> Python tests for Lambda<br>
      <b>7.</b> Deploy all resources via a Serverless Application Model (SAM) template instead of using the console!<br>
      <b>8.</b> Use Github as source control, and Github Actions for CI/CD<br><br>
      Needless to say, I had never done anything like this before - but I saw it as an opportunity to build on my learning. It was a huge challenge, and took me several weeks alongside my coursework to complete. There where many evenings when I had absolutely no clue how to tackle the next step. But with a little bit of research and a lot of head-scratching and persistence, I'm happy to report I overcame the challenge! I'll go deeper into specific challenges I faced during this project in my next post.</p>
      <img src="images/architecture.png" alt="Certified Cloud Practioner Badge" class="architecture"><br>
      <p>I made this diagram showing my architecture and you can see the finished project <a href="/">here</a>. It was such a rewarding experience and my confidence in my practical skills has skyrocketed.<br><br> 
      If you've made it this far - I highly recommend the challenge if you're looking to test your skills! There's a supportive community and a plethora of learning materials available at the <a href="https://cloudresumechallenge.dev/docs/the-challenge/">Cloud Resume Challenge</a>. Finally, I'd like to thank Forest Brazeal and the CRC community for their efforts in making the cloud accessible to all.<br>
    </p>
</div>
<hr class="descriptionline">
<script src="date.js"></script>
</body>
</html>