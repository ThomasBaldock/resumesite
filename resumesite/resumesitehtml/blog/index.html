<html>
<head>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400,700,900,400italic,700italic,900italic|Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="test.css">
    <title>Thomas Baldock's Blog</title>
    <meta name="viewport" content="width=device-width">
    <script>
      fetch('https://57vvf01f32.execute-api.ap-southeast-2.amazonaws.com/Prod/put')
            .then(() => fetch('https://57vvf01f32.execute-api.ap-southeast-2.amazonaws.com/Prod/get'))
            .then(response => response.json())
            .then(data => {
                document.getElementById('visitorCount').innerText = data['counter']
            })
      </script>
</head>
<body>
<div class="links"><a href=mailto:thomas.m.baldock@gmail.com>Email</a> &emsp; <a href="https://www.linkedin.com/in/thomas-m-baldock" target="_blank">LinkedIn</a>  &emsp; <a href="https://github.com/ThomasBaldock" target="_blank">Github</a> &emsp; <a href="/blog">Blog</a> &emsp; <a href="/study-notes">Study Notes</a> </div>
<div class="head">
<div class="thomasbaldockheader"><a href="/" style="text-decoration: none">Thomas Baldock</a></div>
<div class="subhead"> Melbourne, Australia - 
  <div class="display-date">
      <span id="day">day</span>,
      <span id="month">month</span>
      <span id="daynum">00</span>
      <span id="year">0000</span>
    </div></div>
    <div class="visitorcount"><span style="font-style: italic;">View number: <span id="visitorCount">loading...</span></div>
</div>
<div class="badges"><img src="images/cloud-practioner-badge.png" alt="Certified Cloud Practioner Badge" width="100" height="100"><img src="images/restart-graduate-badge.png" alt="AWS Re/Start Graduate Badge" width="100" height="100"></div><br>
<div class="contentb">
  <div class="collumnb">

    <hr class="descriptionline"><br>

    <div class="blogtitle"><a href="/blog/cs-5-datastructures" style="text-decoration: none">Friday 10th of March</a></div>
    <span class="blogheadline">C U L8R</span><br>
    <h3>Labs - Inheritance</h3>
    While initially daunting, this lab ended up being quite easy to complete. The only issue I came across was a small error although it took my a while to identify<br><br>
    I was able to allocate memory for each new person, and then then set the values for each of the new person's variables, however I was not returning these values and thus not populating each new person into the family tree.<br><br>
    Once I changed the return NULL to return new_person my code succeeded.<br><br> 
    Just a matter of not reading all the supplied code throughly, because I had overlooked the TODO in the code supplied by CS50.<br><br>
    Just as an extra, I was receiving a valgrind error and segmentation dump because I was not freeing the memory used for current person, because my freeing function was working on the p structure, not the current person structure<br><br>
    Once I returned the current person to p, I didn't need to free the memory used by current person directly. This was managed by using the free function with 'p' as the argument.<br><br>
    <a href="/blog/cs-5-datastructures">Read more.</a><br><br>  

    <hr class="descriptionline"><br>

    <div class="blogtitle"><a href="/blog/cs-4-memory" style="text-decoration: none">Thursday, 16th of Febuary</a></div>
    <span class="blogheadline">COMMITTING TO MEMORY</span><br>    
    <h3>Labs - Smiley</h3>
    <p>
    For this first lab exercise we needed to transform a smiley face represented by black and white pixels by changing the black pixels into a new colour.<br><br>
    The majority of the code was already provided for us. All we needed to do was provide the code for the colourise function inside of a helpers.c file, which was called in the main function of the colourise file. To link the helpers function to the main function in colourise file, the colourise function was initialised in the beginning of the helpers file, instead of the usual main. These two c files were then linked by the makefile also provided to us already.<br><br>
    Once I wrapped my head around this new approach, I set about planning my approach. I realised that the three input parapets of the colourise function gave us hint on how to approach lab. We were given the image height width and the array of pixels. Immediately my mind want to a solution that involved for loops which iterated through values up to the height and width, much like our solutions to previous tasks like the Mario Pyramid. By this point, such a solution comes easily.<br><br>
    The difficulty I faced in this lab was identifying how to represent the 24-bit colour of each pixel. I overlooked the information in the Lab background which explained to us how the RGBTriple structure was made. <br><br>
    <img src="images/image1.jpg" alt="Correct structure" class="cloudhead"><br><br>
    I knew that I needed to use a for loop, and for each pixel which was found to be black, using an if statement to change it into the colour I desired. My first attempt at representing the pixels was using (0,0,0). I then tried to use a hexadecimal system, binding all 3 bytes together (0x000000). After several errors, searching online for answers, I reread the lab background and found the RGBTRIPLE structure which put my on the right track.<br><br>
    Using the hint which told me that each individual colour of a pixel could be called by pixel.rgbtBlue, I had both the correct strategy and syntax needed to successfully complete the lab.<br>
    </p>
    <a href="/blog/cs-4-memory">Read more.</a><br><br>
      
    <hr class="descriptionline"><br>
    <div class="blogtitle"><a href="/blog/cs-3-algorithms" style="text-decoration: none">Thursday, 9th of Febuary</a></div>
    <span class="blogheadline">THE BIG A WORD</span><br><br> 
    <p>I have decided to take a new approach with my blog posts because I am now using Notion as a tool to manage information and take notes for my courses. From now on, I'll only document my experience with the problem sets in my remaining CS50x blog posts. My summary of the week's learning will instead be found in study notes. This week, we returned to the topic of algorithms, which were introduced in Week 0 as the components that transform inputs into outputs. With a deeper understanding of data types and arrays, we can now perform more advanced transformations and improve the efficiency of our code.<br><br>
    This week's lecture notes can be found <a href="/study-notes/cs50/01-cs50x/03-algorithms"> here</a>. Our lecture and lab discussed Big O notation as we compared the efficiency of different sorting algorithms. However, our problem sets focused on consistent and successful sorts rather than speed.<br><br> 
    I encountered my biggest challenge this week when small errors in my code resulted in inaccurate answers. My understanding of how to write "correct" code was high and while it also appeared legitimate, as no errors were presented when compiling, I was not achieving the expected results. I learned that understanding style and form is not the same as accuracy. I need to pay closer attention to how my algorithms handle information in each step and use debugging tools to track the flow of my algorithms.<br><br>
    My main takeaway from the week is that I need to be mindful of the information flow in my algorithms and use debugging tools, such as local variables and watch expressions, to ensure efficiency and accuracy. I'm making this week's blog more of a diary entry to keep myself accountable and stay on track, as I have also taken on a part-time cybersecurity course and don't want to fall behind.<br><br></p>
    <a href="/blog/cs-3-algorithms">Read more.</a><br><br>

    <hr class="descriptionline"><br>
    <div class="blogtitle"><a href="/blog/cs-2-arrays" style="text-decoration: none">Tuesday, 17th of January 2023</a></div>
    <span class="blogheadline">An Awry Array</span><br><br>
    <img src="images/compuer-chip.png" alt="Computer-image" class="cloudhead"><br>
    
    In week 2 of edX's CS50x, we returned to our study of the programming language C. This week we took a deeper look at the building-blocks of computers and how a programming language works from the bottom up.<br><br>  
    I went into this week confidently after last week's success but struck the wall in the last problem set. I will explain in detail later however I learnt many things - not just about that particular problem set - but also how to approach issues more generally.<br><br> 
    We started the week returning to the concept of compiling. In Week 1 we had used been using the make utility to 'compile' our source code. This week we learnt that this utility is not actually a compiler, rather, it is a command which executes the compiler for C, called Clang, along with some arguments pre-programmed by CS50x. <br><br>
    I did some research of my own to better understand this utility. I discovered outside of the Integrated Development Environment provided by CS50, the make utility needs a makefile to provide the process with the necessary instructions and commands. <br><br>
    I recalled I used a Makefile when I completed the Cloud Resume challenge. You can read about my Cloud Resume here. This file was used by Amazon Web Services Serverless Application Model (AWS SAM), which is a Command Line Interface tool which can build serverless applications on AWS. The Makefile was used to automate the building process when we pushed our code from Github to AWS. Several macros were stored in the file and each one provided AWS SAM with one or more commands, along with any dependencies, which needed to be executed by the compiler. I still don't have a complete grasp of how it works, but being able to link this concept to a previous project strengthened my understanding.<br><br>
    To push this thinking even further, this realisation also gave me a better understanding of how AWS SAM works as well. Effectively, running this tool packages your files in a format with can be understood by the AWS Cloud infrastructure. In other words, we are compiling the code from source code into AWS Cloud machine code.<br><br>
    Back in this week's learning, we investigated the stages that a compiler like Clang goes through. <br><br>
    First is preprocessing. This involves transferring header files into the source code which is to be converted.<br><br>
    Second is a step, also called compiling. In this step, the program is converted into assembly code. This is where architectures like x86 and ARM begin to differ. <br><br>
    The third step, assembling, transforms assembly code into machine code (binary, i.e. 0s and 1s).<br><br>
    The final step, linking, converts the code from included libraries and combines it with the program's machine code. From this point the executable file is outputted.  From my experience, the final result is often called the binary of a program. I had trouble understanding what this mean in the past, so I'm glad for the clarification. <br><br>
    Perhaps as some foreshadowing from our teachers of what lay ahead with this week's problem sets, we were told about the inevitability of writing mistakes, or bugs, when coding. We were then provided with some debugging techniques to eliminate these errors. <br>
    
    <a href="/blog/cs-2-arrays">Read more.</a><br><br>


   
    <div class="blogtitle"><a href="/blog/cs-1-c" style="text-decoration: none">Wednesday, 7th of December</a></div>
    <span class="blogheadline">The Man and the C</span><br><br>
    <img src="images/mario.png" alt="Mario" class="cloudhead"><br>
    <p>
      After a short holiday I've returned to continue with my learning in cs50's Introduction to Computer Science. This week, we progress from the visual coding language Scratch to a more powerful language called C.<br><br>
      This will be another introductory language which we will use as a springboard to other languages in later weeks. The aim is to gain an understanding of the typical framework of programming languages.<br><br>
      To start the lecture, we recalled our understanding of the basic ideas in programming, like functions, conditionals, and loops and learnt how they can be executed in C.<br><br>
      We learned that C is a more opaque language than Scratch - requiring a knowledge of a more sophisticated and less human-readable syntax - but there are methods to ensure code is made easier to follow. Methods include formatting of code, efficiency of algorithms, adding clear comments and whether the code solves problem as intended.<br><br>
      Our first program mirrored that of our first Scratch demo, printing “hello, world”. Immediately, it's clear there are a few extra requirements in this language for a simple program to function, such as the inclusion of Standard Input and Output header (stdio.h) and the loading of a main function.<br><br>
      After this demo we learnt about Integrated Development Environments which can be used write, translate and run code and terminal windows. And building on our understanding of the binary system - which computers use to represent and process information - we learnt the difference between source code and machine code.<br><br>
      In this week's study, for example, source code is written in the high-level, moderately human-readable language C, however, in it's initial form, it is not able to give instructions to a computer. The source code, in order for the computer to understand it, needs to be translated - or compiled - into machine code by a program called a compiler. In the IDE provided by this course, we can compile our source code by using the 'make' command.<br><br>
      After an overview of Linux concepts necessary for this weeks problems sets we moved onto working through some basic programs in C, in order to introduce to us to the syntax and style requirements of C and how it uses data types, functions, arguments, loops, operators, etc.<br><br>
      <a href="/blog/cs-1-c">Read more.</a><br><br>
    <hr class="descriptionline"><br>
    
    <h3>Thursday, 6th of October</h3>
    <span class="blogheadline">Getting Started</span><br><br> 
    <iframe width="485" height="273" src="https://www.youtube.com/embed/caXPtlRzH80" class="game" title="The Cloud Developer Workbook - 01 - Getting Started" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>
    <hr class="descriptionline"><br>

    <div class="blogtitle"><a href="/blog/cs-0-scratch" style="text-decoration: none">Wednesday, 5th of October</a></div>
    <span class="blogheadline">The Shell Game</span><br><br> 
    <img src="images/conjurer.jpg" alt="The Shell Game" class="cloudhead"><br>
      <p>Just a quick one here. I have started <a href="https://www.edx.org/course/introduction-computer-science-harvardx-cs50x" target="_blank">cs50's Introduction to Computer Science</a> and made it through week 0. In this block we were introduced to the fundamental concepts of computer science.<br><br>
        We touched on how the binary system is used to represent all kinds of information e.g. text, images, videos, sounds, emojis, etc on computers. We learnt computer science can be simplified into two components - inputs and outputs, and that essentially, computer science is a form of problem solving, using algorithms (step-by-step instructions on how to process inputs to produce required outputs).<br><br>
        Through a basic example (finding a name in a phone book) we visualised how an algorithm's efficiency can be calculated. We used this example to show how an algorithm's efficiency can be represented using a simple chart.<br><br>
    <img src="images/algorithmic-efficiency.png" alt="Algorithmic-efficiency" class="cloudhead"><br>
        We then experminted with writing 'pseudocode' using quasi functions (pick up), conditionals (if, else if), loops (for, return to line x) and boolean expressions (is person on page? yes or no). The pseudocode that was used to find any name in the phone book was this:<br><br>
        1  &nbsp;Pick up phone book<br>
        2  &nbsp;Open to middle of phone book<br>
        3  &nbsp;Look at page<br>
        4  &nbsp;If person is on page<br>
        5  &nbsp;&emsp;Call person<br>
        6  &nbsp;Else if person is earlier in book<br>
        7  &nbsp;&emsp;Open to middle of left half of book<br>
        8  &nbsp;&emsp;Go back to line 3<br>
        9  &nbsp;Else if person is later in book<br>
        10 &nbsp;&emsp;Open to middle of right half of book<br>
        11 &nbsp;&emsp;Go back to line 3<br>
        12 &nbsp;Else<br>
        13 &nbsp;&emsp;Quit<br><br>
        The lecture finished with an introduction to the graphical programming language called <a href="https://scratch.mit.edu/" target="_blank">Scratch</a>, developed by MIT. This language has a highly human-readable form and bridges the gap between pseudocode and computer code. We had a look at some examples of previous student's projects, before we were sent out into the ether to come up with and execute our own idea.<br><br>
        After a short time experimenting with the language, I decided to recreate the Shell Game in Scratch. Here's my finished project.<br><hr class="descriptionline"><br>
        <iframe src="https://scratch.mit.edu/projects/741040546/embed" class="game" allowtransparency="true" width="485" height="402" frameborder="0" scrolling="no" allowfullscreen></iframe><br><hr class="descriptionline"><br>
        I've had some experience making a small game with python (battleship) however, this time my efforts were unguided. Admittedly, Scratch is very intuitive - still, working through the entire process helped reinforce some concepts for me. Most notably - the concept of exit status. It took some time for me to work how to integrate the seperate 'puzzle pieces' of my project, until I discovered the 'broadcast message' feature of Scratch. From this point, it was much clearer how I could integrate my puzzle pieces together.<br><br>
        I had a lot of fun with this week's block - particularly David J. Malan's energetic stage presence. He seems to me to be the Freddie Mercury of the Computer Science world! I'm really looking forward to next week's learning.
      </p>
      </p><br><hr class="descriptionline"><br>

    
    <div class="blogtitle"><a href="/blog/hello-world" style="text-decoration: none">Thursday, 8th of September</div></a>
    <p>Hello world! It's been quite some time since my last blog, back at the beginning of my journalism career.<br><br> 
      Now I found myself neither gainfully employed as a member of the press nor in the manufacturing field I followed it into. And yet, here I am, more excited for the future than I have ever been. So what exactly am I so excited about? Before I start, I'd like to acknowledge I will be breaking the cardinal rule of journalism: never, EVER put yourself in the story. However, not only am I allowing myself to ignore my training - but in this era of personal branding - it is encouraged. I can BE the story.<br><br> 
      So then, what is my story?<br></p>
      <span class="blogheadline">MAN TAKES LEAP OF FAITH INTO CLOUD</span><br><br>
      <img src="images/head-in-the-cloud.png" alt="Head in the cloud" class="cloudhead"><br>
      <p>There are many ways to follow this headline. The truest account - and please respect what remains of my journalistic integrity - goes something like this.<br><br> 
      I've always harboured an interest in computers so when the Digital Jobs Program came on my radar I jumped at the opportunity - even though I was employed at the time as an assistant manager at a manufacturing company. I choose the AWS Re/Start course because it covered a wide variety of topics and would provide a decent foundation for a career change. I didn't know much about cloud computing but the syllabus really appealed to me and I was ready to give it my all.<br><br> 
      So I left my job to take on this program and take a step into the great unknown.
      Luckily for me, I loved the course from the outset. I was spending my days and evenings absorbing as much new information as I possibly could. I then came across Forest Brazeal's 'Cloud Resume Challenge' which is touted as the ultimate test for anyone looking to get into a cloud career.  The premise of the project is simple - host your resume in the cloud. There are, however, several conditions.<br><br> 
      <b>1.</b> Get an AWS certification<br>
      <b>2.</b> Write the resume in HTML & styled with CSS<br>
      <b>3.</b> Deploy as an Amazon S3 Static website<br>
      <b>4.</b> Use a custom DNS Domain name with HTTPS security<br>
      <b>5.</b> Include a visitor counter made from Javascript, DynamoDB, API Gateways and Lambda functions (written in Python)<br>
      <b>6.</b> Python tests for Lambda<br>
      <b>7.</b> Deploy all resources via a Serverless Application Model (SAM) template instead of using the console!<br>
      <b>8.</b> Use Github as source control, and Github Actions for CI/CD<br><br>
      Needless to say, I had never done anything like this before - but I saw it as an opportunity to build on my learning. It was a huge challenge, and took me several weeks alongside my coursework to complete. There where many evenings when I had absolutely no clue how to tackle the next step. But with a little bit of research and a lot of head-scratching and persistence, I'm happy to report I overcame the challenge! I'll go deeper into specific challenges I faced during this project in my next post.</p>
      <img src="images/architecture.png" alt="Certified Cloud Practioner Badge" class="architecture"><br>
      <p>I made this diagram showing my architecture and you can see the finished project <a href="/">here</a>. It was such a rewarding experience and my confidence in my practical skills has skyrocketed.<br><br> 
      If you've made it this far - I highly recommend the challenge if you're looking to test your skills! There's a supportive community and a plethora of learning materials available at the <a href="https://cloudresumechallenge.dev/docs/the-challenge/">Cloud Resume Challenge</a>. Finally, I'd like to thank Forest Brazeal and the CRC community for their efforts in making the cloud accessible to all.<br>
    </p>
</div>
<hr class="descriptionline">
<script src="date.js"></script>
</body>
</html>